package com.lucasxf.ed.service;

import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.lucasxf.ed.domain.PokTag;
import com.lucasxf.ed.domain.PokTagSuggestion;
import com.lucasxf.ed.domain.UserTag;
import com.lucasxf.ed.dto.TagSuggestionResponse;
import com.lucasxf.ed.exception.TagNotFoundException;
import com.lucasxf.ed.repository.PokRepository;
import com.lucasxf.ed.repository.PokTagRepository;
import com.lucasxf.ed.repository.PokTagSuggestionRepository;
import com.lucasxf.ed.repository.TagRepository;
import com.lucasxf.ed.repository.UserTagRepository;

/**
 * AI tag suggestion pipeline using keyword extraction (Option B).
 *
 * <p>Suggestions are generated by matching a user's active tag names against the
 * title and content of a POK (case-insensitive, whole-word). Suggestions are stored
 * as {@link PokTagSuggestion} records and surfaced to the user for approval or rejection.
 *
 * @author Lucas Xavier Ferreira
 * @since 2026-02-25
 */
@Service
@Transactional
public class TagSuggestionService {

    private final PokRepository pokRepository;
    private final TagRepository tagRepository;
    private final UserTagRepository userTagRepository;
    private final PokTagRepository pokTagRepository;
    private final PokTagSuggestionRepository suggestionRepository;

    public TagSuggestionService(PokRepository pokRepository,
                                TagRepository tagRepository,
                                UserTagRepository userTagRepository,
                                PokTagRepository pokTagRepository,
                                PokTagSuggestionRepository suggestionRepository) {
        this.pokRepository = pokRepository;
        this.tagRepository = tagRepository;
        this.userTagRepository = userTagRepository;
        this.pokTagRepository = pokTagRepository;
        this.suggestionRepository = suggestionRepository;
    }

    // ===== suggestTagsForPok =====

    /**
     * Generates tag suggestions for a POK by matching the user's active tags against
     * the POK's title and content.
     *
     * <p>Runs asynchronously after POK creation. Skips:
     * <ul>
     *   <li>Tags already assigned to the POK</li>
     *   <li>Tags that already have a PENDING suggestion</li>
     * </ul>
     *
     * @param pokId  the POK to analyze
     * @param userId the owner's ID
     */
    @Async
    public void suggestTagsForPok(UUID pokId, UUID userId) {
        var pokOpt = pokRepository.findByIdAndDeletedAtIsNull(pokId);
        if (pokOpt.isEmpty()) {
            return;
        }
        var pok = pokOpt.get();
        String text = (pok.getTitle() + " " + pok.getContent()).toLowerCase();

        List<UserTag> userTags = userTagRepository.findByUserIdAndDeletedAtIsNull(userId);
        List<PokTagSuggestion> existing = suggestionRepository.findByPokIdAndUserId(pokId, userId);
        Set<String> alreadySuggested = existing.stream()
                .map(s -> s.getSuggestedName().toLowerCase())
                .collect(Collectors.toSet());

        for (UserTag userTag : userTags) {
            String tagName = userTag.getTag().getName();
            String tagLower = tagName.toLowerCase();

            // Skip if already assigned
            if (pokTagRepository.findByPokIdAndTagId(pokId, userTag.getTag().getId()).isPresent()) {
                continue;
            }

            // Skip if already suggested
            if (alreadySuggested.contains(tagLower)) {
                continue;
            }

            // Match: tag name appears in title or content (simple substring match)
            if (containsKeyword(text, tagLower)) {
                suggestionRepository.save(new PokTagSuggestion(pokId, userId, tagName));
            }
        }
    }

    // ===== getPendingSuggestions =====

    /**
     * Returns all PENDING suggestions for a POK owned by the authenticated user.
     *
     * @param pokId  the POK's ID
     * @param userId the authenticated user's ID (ownership check)
     * @return list of pending suggestion responses
     */
    @Transactional(readOnly = true)
    public List<TagSuggestionResponse> getPendingSuggestions(UUID pokId, UUID userId) {
        return suggestionRepository.findByPokIdAndUserIdAndStatus(pokId, userId, PokTagSuggestion.Status.PENDING)
                .stream()
                .map(TagSuggestionResponse::from)
                .toList();
    }

    // ===== approveSuggestion =====

    /**
     * Approves a pending suggestion, creating or upgrading a {@link PokTag}.
     *
     * <p>If the tag is already assigned:
     * <ul>
     *   <li>Upgrades the source to {@link PokTag.Source#AI_EDITED}</li>
     * </ul>
     * If not yet assigned, creates a new {@link PokTag} with {@link PokTag.Source#AI}.
     *
     * @param suggestionId the suggestion to approve
     * @param userId       the authenticated user's ID
     * @throws TagNotFoundException if the suggestion does not exist or belongs to another user
     */
    public void approveSuggestion(UUID suggestionId, UUID userId) {
        PokTagSuggestion suggestion = findOwnedSuggestion(suggestionId, userId);

        var tagOpt = tagRepository.findByNameIgnoreCase(suggestion.getSuggestedName());
        if (tagOpt.isEmpty()) {
            // Global tag no longer exists (edge case) â€” just mark approved
            suggestion.approve();
            suggestionRepository.save(suggestion);
            return;
        }

        var tag = tagOpt.get();
        Optional<PokTag> existingAssignment = pokTagRepository.findByPokIdAndTagId(
                suggestion.getPokId(), tag.getId());

        if (existingAssignment.isPresent()) {
            existingAssignment.get().setSource(PokTag.Source.AI_EDITED);
        } else {
            pokTagRepository.save(new PokTag(suggestion.getPokId(), tag.getId(), PokTag.Source.AI));
        }

        suggestion.approve();
        suggestionRepository.save(suggestion);
    }

    // ===== rejectSuggestion =====

    /**
     * Rejects a pending suggestion. No tag is created.
     *
     * @param suggestionId the suggestion to reject
     * @param userId       the authenticated user's ID
     * @throws TagNotFoundException if the suggestion does not exist or belongs to another user
     */
    public void rejectSuggestion(UUID suggestionId, UUID userId) {
        PokTagSuggestion suggestion = findOwnedSuggestion(suggestionId, userId);
        suggestion.reject();
        suggestionRepository.save(suggestion);
    }

    // ===== helpers =====

    private PokTagSuggestion findOwnedSuggestion(UUID suggestionId, UUID userId) {
        return suggestionRepository.findByIdAndUserId(suggestionId, userId)
                .orElseThrow(() -> new TagNotFoundException("Suggestion not found: " + suggestionId));
    }

    /**
     * Returns {@code true} if {@code text} contains {@code keyword}.
     * Normalizes hyphens to spaces so that tag "spring-boot" matches "Spring Boot" in text.
     */
    private boolean containsKeyword(String text, String keyword) {
        // Direct match (e.g. "docker" in "I use docker daily")
        if (text.contains(keyword)) {
            return true;
        }
        // Hyphen-normalized match (e.g. "spring-boot" matches "spring boot")
        String normalizedText = text.replace('-', ' ');
        String normalizedKeyword = keyword.replace('-', ' ');
        return normalizedText.contains(normalizedKeyword);
    }
}
